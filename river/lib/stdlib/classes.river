def attr_reader(name)
  # TODO: the "do" block here will bind, in its closure, to the object that attr_reader was invoked on
  # What we want is to "bind" the local "name" - kinda like a closure, but we want the "do" block to dynamically
  # update its "context/self" to whatever object it was invoked on - like a normal method
  set_method name, do
    get_member name
  end
end
def root_attr_reader(name)
  set_method name, do
    root.get_member name
  end
end
def tap(block)
  block.call self
  self
end
def tap_eval(block)
  self.eval block
  self
end

root_attr_reader :class_prototype
root_attr_reader :classes
root_attr_reader :class_instance_prototype

@class_prototype = new.tap_eval do
  attr_reader :name
  attr_reader :prototype

  @name = "class_prototype"

  def create_prototype(klass)
    class_prototype.new.tap_eval do
      @class = klass
    end
  end
end

@class_instance_prototype = new.tap_eval do
  def class
    @class || super
  end
end

@classes = new.tap_eval do
  def get_class(name)
    get_member(name) || new_class(name)
  end

  def new_class(name)
    attr_reader name
    set_member(name, (a = class_prototype.new).tap_eval(do
      @name = name
      @prototype = class_instance_prototype.new
    end))
    a
  end
end

def class(name, block)
  classes.get_class(name).tap_eval do
    prototype.eval block
  end
end
